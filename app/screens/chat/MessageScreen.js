import React, { useState, useEffect, useRef, useContext } from "react";
import {
  SafeAreaView,
  View,
  Text,
  KeyboardAvoidingView,
  Platform,
  StyleSheet,
  Keyboard,
} from "react-native";
import { useNavigation } from "@react-navigation/native";
import ChatHeader from "./header/ChatHeader";
import SearchHeader from "./optional/name/searchMessage/SearchHeader";
import SearchFooter from "./optional/name/searchMessage/SearchFooter";
import ChatFooter from "./footer/ChatFooter";
import Conversation from "./message/Conversation";
import MessageScreenStyle from "./MessageScreenStyle";
import Fuse from "fuse.js";
import { api } from "@/app/api/api";
import { AuthContext } from "@/app/auth/AuthContext";

const MessageScreen = ({ route, navigation }) => {
  const { userInfo } = useContext(AuthContext);

  const { conversation, startSearch, receiver } = route.params;

  const [messages, setMessages] = useState([]);
  const [searchQuery, setSearchQuery] = useState("");
  const [isSearching, setIsSearching] = useState(startSearch || false);
  const [highlightedMessageIds, setHighlightedMessageIds] = useState([]);
  const [highlightedMessageId, setHighlightedMessageId] = useState(null);
  const [currentSearchIndex, setCurrentSearchIndex] = useState(0);
  const [isLoadingMore, setIsLoadingMore] = useState(true);
  const [hasMoreMessages, setHasMoreMessages] = useState(true);
  const [nextCursor, setNextCursor] = useState(null);

  const flatListRef = useRef(null);

  const calculateLastActive = (lastActive) => {
    const now = new Date();
    const lastActiveDate = new Date(lastActive);
    const diffInMinutes = Math.floor((now - lastActiveDate) / (1000 * 60));

    if (diffInMinutes < 2) return "ƒêang ho·∫°t ƒë·ªông";
    if (diffInMinutes < 60) return `Truy c·∫≠p ${diffInMinutes} ph√∫t tr∆∞·ªõc`;
    if (diffInMinutes < 1440)
      return `Truy c·∫≠p ${Math.floor(diffInMinutes / 60)} gi·ªù tr∆∞·ªõc`;
    return `Truy c·∫≠p ${Math.floor(diffInMinutes / 1440)} ng√†y tr∆∞·ªõc`;
  };

  const handleSendMessage = (message) => {
    if (!conversation?.conversationId) {
      alert("Kh√¥ng th·ªÉ g·ª≠i tin nh·∫Øn: Cu·ªôc tr√≤ chuy·ªán kh√¥ng t·ªìn t·∫°i.");
      return;
    }

    const newMessage = {
      conversationId: conversation.conversationId, // Include conversationId
      content: message.content, // Include content
      messageDetailId: `msg_${Date.now()}`,
      createdAt: new Date().toISOString(),
      senderId: userInfo.userId,
    };

    setMessages((prev) => {
      const updatedMessages = [...(prev || []), newMessage].sort(
        (a, b) => new Date(a.createdAt) - new Date(b.createdAt)
      );
      // .reverse(); // Sort messages by createdAt in descending order
      return updatedMessages;
    });
    // Send the message to the server
    api
      .sendMessage({
        conversationId: newMessage.conversationId,
        content: newMessage.content,
      })

      .catch((error) => {
        console.error("L·ªói g·ª≠i tin nh·∫Øn:", error);

        // Handle specific error cases
        if (error.message.includes("Conversation not found or access denied")) {
          alert(
            "Kh√¥ng th·ªÉ g·ª≠i tin nh·∫Øn: Cu·ªôc tr√≤ chuy·ªán kh√¥ng t·ªìn t·∫°i ho·∫∑c b·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p."
          );
        } else {
          alert("ƒê√£ x·∫£y ra l·ªói khi g·ª≠i tin nh·∫Øn. Vui l√≤ng th·ª≠ l·∫°i.");
        }
      });
  };

  useEffect(() => {
    if (!conversation?.conversationId) {
      console.error("L·ªói: Cu·ªôc tr√≤ chuy·ªán kh√¥ng t·ªìn t·∫°i.");
      setMessages([]); // Clear messages if conversation is invalid
      return;
    }

    const fetchMessages = async () => {
      try {
        const response = await api.getMessages(conversation.conversationId);
        const { messages, nextCursor, hasMore } = response;

        setMessages(messages || []);
        setNextCursor(true);
        setHasMoreMessages(true);
      } catch (error) {
        console.error("L·ªói l·∫•y tin nh·∫Øn:", error);
        setMessages([]);
      }
    };

    fetchMessages();
  }, [conversation?.conversationId]);

  const loadMoreMessages = async () => {
    // setMessages([]);
    // if (isLoadingMore || !hasMoreMessages || !nextCursor) {
    //   console.log("Kh√¥ng th·ªÉ t·∫£i th√™m tin nh·∫Øn:");
    //   console.log("isLoadingMore:", isLoadingMore);
    //   console.log("hasMoreMessages:", hasMoreMessages);
    //   console.log("nextCursor:", nextCursor);
    //   return;
    // }

    console.log("B·∫Øt ƒë·∫ßu t·∫£i th√™m tin nh·∫Øn...");
    setIsLoadingMore(true);

    // L·∫•y th·ªùi gian c·ªßa tin nh·∫Øn c≈© nh·∫•t
    const lastMessageTime = messages[0]?.createdAt;
    console.log("Th·ªùi gian c·ªßa tin nh·∫Øn c≈© nh·∫•t:", lastMessageTime);

    try {
      console.log("G·ª≠i y√™u c·∫ßu API v·ªõi nextCursor:", nextCursor);
      const response = await api.getMessages(
        conversation.conversationId,
        lastMessageTime,
        "before", // load th√™m tin c≈©
        20
      );

      const {
        messages: moreMessages,
        nextCursor: newCursor,
        hasMore,
      } = response;

      console.log("Tin nh·∫Øn m·ªõi t·∫£i:", moreMessages);
      console.log("nextCursor m·ªõi:", newCursor);
      console.log("hasMore t·ª´ API:", hasMore);

      setMessages((prev) => {
        const updatedMessages = [...moreMessages, ...prev];
        console.log("Danh s√°ch tin nh·∫Øn sau khi c·∫≠p nh·∫≠t:", updatedMessages);
        return updatedMessages;
      });

      setNextCursor(newCursor);
      setHasMoreMessages(hasMore);
    } catch (error) {
      console.error("L·ªói t·∫£i th√™m tin nh·∫Øn:", error);
    } finally {
      setIsLoadingMore(false);
      console.log("Ho√†n th√†nh t·∫£i th√™m tin nh·∫Øn.");
    }
  };
  useEffect(() => {
    if (!searchQuery.trim()) {
      setHighlightedMessageIds([]);
      setHighlightedMessageId(null);
      return;
    }

    const fuse = new Fuse(messages, {
      keys: ["content"],
      threshold: 0.6,
      distance: 100,
    });

    const results = fuse.search(searchQuery).map((res) => res.item);

    // S·∫Øp x·∫øp danh s√°ch theo th·ªùi gian g·ª≠i
    const sortedResults = results.sort(
      (a, b) => new Date(a.createdAt) - new Date(b.createdAt)
    );

    const messageIds = sortedResults.map((msg) => msg.messageDetailId);
    setHighlightedMessageIds(messageIds);
    setCurrentSearchIndex(messageIds.length - 1); // M·∫∑c ƒë·ªãnh ch·ªçn tin nh·∫Øn cu·ªëi

    console.log("Danh s√°ch ID tin nh·∫Øn t√¨m ƒë∆∞·ª£c:", messageIds);

    if (messageIds.length > 0) {
      scrollToMessage(messageIds.length - 1); // Cu·ªôn ƒë·∫øn tin nh·∫Øn cu·ªëi
    }
  }, [searchQuery, messages]);

  // Cu·ªôn ƒë·∫øn tin nh·∫Øn
  const scrollToMessage = (index) => {
    if (index < 0 || index >= highlightedMessageIds.length) return;

    const messageId = highlightedMessageIds[index];
    const messageIndex = messages.findIndex(
      (msg) => msg.messageDetailId === messageId
    );

    if (messageIndex !== -1) {
      setTimeout(() => {
        flatListRef.current?.scrollToIndex({
          index: messageIndex,
          animated: true,
          viewPosition: 0.5,
        });
        setHighlightedMessageId(messageId); // ƒê√°nh d·∫•u tin nh·∫Øn n√†y
      }, 300);
    }
  };

  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: "#ebecf0" }}>
      <ChatHeader
        navigation={navigation}
        receiver={receiver}
        conversation={conversation}
        lastActiveStatus={calculateLastActive(receiver?.lastActive)}
      />
      {isSearching && (
        <View style={StyleSheet.absoluteFill}>
          <SearchHeader
            onCancel={() => {
              setIsSearching(false);
              setSearchQuery("");
              setHighlightedMessageIds([]);
              setHighlightedMessageId(null);

              // üî• Ch·ªù m·ªôt ch√∫t ƒë·ªÉ ƒë·∫£m b·∫£o React c·∫≠p nh·∫≠t state tr∆∞·ªõc khi render l·∫°i header
              setTimeout(() => {
                navigation.setParams({ receiver }); // ƒê·∫£m b·∫£o receiverId v·∫´n t·ªìn t·∫°i
              }, 100);
            }}
            onSearch={setSearchQuery}
          />
        </View>
      )}
      <KeyboardAvoidingView
        behavior={Platform.OS === "ios" ? "padding" : "padding"}
        keyboardVerticalOffset={Platform.OS === "ios" ? 64 : 0}
        style={{ flex: 1 }}
      >
        {messages?.length > 0 ? (
          <Conversation
            conversation={{ messages }}
            senderId={userInfo.userId}
            highlightedMessageIds={highlightedMessageIds}
            highlightedMessageId={highlightedMessageId}
            searchQuery={searchQuery}
            flatListRef={flatListRef}
            receiver={receiver}
            keyboardShouldPersistTaps="handled" // Ensure taps don't dismiss the keyboard
            onLoadMoreMessages={loadMoreMessages}
            isLoadingMore={isLoadingMore}
          />
        ) : (
          <Text style={styles.emptyText}>Kh√¥ng c√≥ tin nh·∫Øn n√†o.</Text>
        )}
      </KeyboardAvoidingView>
      <ChatFooter onSendMessage={handleSendMessage} />
      {isSearching && (
        <View style={StyleSheet.absoluteFill}>
          <SearchFooter
            resultCount={highlightedMessageIds.length}
            currentIndex={currentSearchIndex}
            onNext={() => {
              setCurrentSearchIndex((prev) => {
                const nextIndex =
                  prev + 1 < highlightedMessageIds.length ? prev + 1 : prev; // Kh√¥ng xu·ªëng n·∫øu l√† tin nh·∫Øn cu·ªëi
                scrollToMessage(nextIndex);
                return nextIndex;
              });
            }}
            onPrevious={() => {
              setCurrentSearchIndex((prev) => {
                const prevIndex = prev - 1 >= 0 ? prev - 1 : prev; // Kh√¥ng l√™n n·∫øu l√† tin nh·∫Øn ƒë·∫ßu
                scrollToMessage(prevIndex);
                return prevIndex;
              });
            }}
          />
        </View>
      )}
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  emptyText: {
    textAlign: "center",
    marginTop: 20,
    fontSize: 16,
    color: "gray",
  },
});

export default MessageScreen;
