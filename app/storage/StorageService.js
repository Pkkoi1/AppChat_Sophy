import * as FileSystem from "expo-file-system";
const { StorageAccessFramework } = FileSystem;

import AsyncStorage from "@react-native-async-storage/async-storage";

const DIRECTORY_KEY = "SHOPY_DIRECTORY_URI";
let isWriting = false;

export const pickExternalDirectory = async () => {
  try {
    const dirUri =
      await StorageAccessFramework.requestDirectoryPermissionsAsync();
    if (dirUri.granted) {
      await AsyncStorage.setItem(DIRECTORY_KEY, dirUri.directoryUri);
      console.log("‚úÖ Th∆∞ m·ª•c ƒë∆∞·ª£c ch·ªçn:", dirUri.directoryUri);
      return dirUri.directoryUri;
    } else {
      throw new Error("‚ùå Ng∆∞·ªùi d√πng t·ª´ ch·ªëi ch·ªçn th∆∞ m·ª•c");
    }
  } catch (err) {
    console.error("L·ªói khi ch·ªçn th∆∞ m·ª•c:", err);
    throw err;
  }
};

const handleStorageError = async (error) => {
  if (error.message.includes("isn't readable")) {
    console.warn(
      "‚ö†Ô∏è Th∆∞ m·ª•c kh√¥ng th·ªÉ ƒë·ªçc ƒë∆∞·ª£c. ƒêang y√™u c·∫ßu c·∫•p l·∫°i quy·ªÅn..."
    );
    try {
      const dirUri =
        await StorageAccessFramework.requestDirectoryPermissionsAsync();
      if (dirUri.granted) {
        await AsyncStorage.setItem(DIRECTORY_KEY, dirUri.directoryUri);
        console.log(
          "‚úÖ Quy·ªÅn ƒë√£ ƒë∆∞·ª£c c·∫•p l·∫°i cho th∆∞ m·ª•c:",
          dirUri.directoryUri
        );
      } else {
        console.error("‚ùå Ng∆∞·ªùi d√πng t·ª´ ch·ªëi c·∫•p quy·ªÅn.");
      }
    } catch (err) {
      console.error("‚ùå L·ªói khi y√™u c·∫ßu c·∫•p l·∫°i quy·ªÅn:", err);
    }
  } else {
    console.error("‚ùå L·ªói kh√¥ng x√°c ƒë·ªãnh:", error);
  }
};

const getBaseDir = async () => {
  const uri = await AsyncStorage.getItem(DIRECTORY_KEY);
  if (!uri) throw new Error("‚ùå Ch∆∞a c√≥ th∆∞ m·ª•c n√†o ƒë∆∞·ª£c ch·ªçn.");
  return uri;
};

const getUserFileName = async () => {
  const userId = await AsyncStorage.getItem("userId");
  if (!userId) return null;
  return `user_${userId}.json`;
};

const readUserData = async () => {
  const fileName = await getUserFileName();
  console.log("ƒêang ƒë·ªçc file:", fileName);
  if (!fileName) return {};
  return (await readFile(fileName)) || {};
};

const writeUserData = async (data) => {
  const fileName = await getUserFileName();
  if (!fileName) {
    console.warn("‚õî Kh√¥ng th·ªÉ ghi file v√¨ ch∆∞a c√≥ userId.");
    return;
  }
  await writeFile(fileName, data);
};

const writeQueue = [];

const writeFile = async (fileName, data) => {
  const writePromise = new Promise(async (resolve, reject) => {
    const executeWrite = async () => {
      try {
        const dirUri = await getBaseDir();

        const cleanData = JSON.parse(
          JSON.stringify(data, (key, value) => {
            if (typeof value === "undefined" || typeof value === "function") {
              return null;
            }
            if (
              typeof value === "boolean" &&
              value !== true &&
              value !== false
            ) {
              console.warn("‚ùå Gi√° tr·ªã boolean kh√¥ng h·ª£p l·ªá:", value);
              return null;
            }
            return value;
          })
        );

        let content;
        try {
          content = JSON.stringify(cleanData, null, 2);
          JSON.parse(content);
        } catch (err) {
          console.error("‚ùå L·ªói serialize d·ªØ li·ªáu:", err);
          await debugFileContent(fileName);
          throw new Error("D·ªØ li·ªáu kh√¥ng th·ªÉ serialize th√†nh JSON h·ª£p l·ªá");
        }

        const files = await StorageAccessFramework.readDirectoryAsync(dirUri);
        const cleanFileName = fileName.replace(/ \(\d+\)\.json$/, ".json");
        const existingFileUri = files.find((uri) => {
          const decodedUri = decodeURIComponent(uri);
          return (
            decodedUri.endsWith(`/${cleanFileName}`) ||
            decodedUri.match(
              new RegExp(
                `/${cleanFileName.replace(".json", "")}\\s*\\(\\d+\\)\\.json$`
              )
            )
          );
        });

        let fileUri;
        if (existingFileUri) {
          fileUri = existingFileUri;
        } else {
          fileUri = await StorageAccessFramework.createFileAsync(
            dirUri,
            cleanFileName.replace(".json", ""),
            "application/json"
          );
          console.log("‚úÖ T·∫°o t·ªáp m·ªõi:", fileUri);
        }

        await FileSystem.writeAsStringAsync(fileUri, content, {
          encoding: FileSystem.EncodingType.UTF8,
        });

        const duplicateFiles = files.filter((uri) => {
          const decodedUri = decodeURIComponent(uri);
          return (
            decodedUri.match(
              new RegExp(
                `/${cleanFileName.replace(".json", "")}\\s*\\(\\d+\\)\\.json$`
              )
            ) && uri !== fileUri
          );
        });

        for (const duplicate of duplicateFiles) {
          await FileSystem.deleteAsync(duplicate, { idempotent: true });
          console.log("üóëÔ∏è ƒê√£ x√≥a t·ªáp tr√πng l·∫∑p:", duplicate);
        }

        resolve();
      } catch (err) {
        console.error("‚ùå L·ªói ghi t·ªáp:", err);
        await handleStorageError(err);
        reject(err);
      }
    };

    writeQueue.push(executeWrite);
    if (!isWriting) {
      isWriting = true;
      while (writeQueue.length > 0) {
        const nextWrite = writeQueue.shift();
        await nextWrite();
      }
      isWriting = false;
    }
  });

  return writePromise;
};

const readFile = async (fileName) => {
  try {
    const dirUri = await getBaseDir();
    const files = await StorageAccessFramework.readDirectoryAsync(dirUri);
    const cleanFileName = fileName;
    const target = files.find((f) => {
      const decoded = decodeURIComponent(f);
      return (
        decoded.includes(`/${cleanFileName}`) ||
        decoded.includes(`%2F${cleanFileName}`)
      );
    });

    if (!target) {
      console.warn(
        "‚ùå Kh√¥ng t√¨m th·∫•y file tr√πng t√™n trong th∆∞ m·ª•c:",
        cleanFileName
      );
      console.log(
        "üìÇ T·ªáp hi·ªán c√≥:",
        files.map((f) => decodeURIComponent(f))
      );
    }

    const content = await FileSystem.readAsStringAsync(target, {
      encoding: FileSystem.EncodingType.UTF8,
    });
    // console.log("üìÑ ƒê√£ ƒë·ªçc t·ªáp:", target);
    // console.log("üìÑ N·ªôi dung t·ªáp:", content);
    if (!content) return null;

    try {
      return content.message;
    } catch (err) {
      if (!target.includes("Sophy")) {
        await FileSystem.deleteAsync(target, { idempotent: true });
      } else {
        console.warn("‚ö†Ô∏è B·ªè qua x√≥a t·ªáp trong th∆∞ m·ª•c Sophy:", target);
      }
      return null;
    }
  } catch (err) {
    console.error("‚ùå L·ªói ƒë·ªçc t·ªáp:", err);
    await handleStorageError(err);
    return null;
  }
};

export const debugFileContent = async (fileName) => {
  try {
    const dirUri = await getBaseDir();
    const files = await StorageAccessFramework.readDirectoryAsync(dirUri);
    const cleanFileName = fileName.replace(/ \(\d+\)\.json$/, ".json");
    const target = files.find((f) => {
      const decoded = decodeURIComponent(f);
      return (
        decoded.includes(`/${cleanFileName}`) ||
        decoded.includes(`%2F${cleanFileName}`)
      );
    });

    if (!target) {
      console.log("‚ùå Kh√¥ng t√¨m th·∫•y file:", fileName);
      return;
    }

    const content = await FileSystem.readAsStringAsync(target, {
      encoding: FileSystem.EncodingType.UTF8,
    });
    console.log("üìÑ N·ªôi dung file:", content);
    try {
      const parsed = JSON.parse(content);
      console.log("‚úÖ JSON h·ª£p l·ªá:", parsed);
    } catch (err) {
      console.error("‚ùå JSON kh√¥ng h·ª£p l·ªá:", err.message);
    }
  } catch (err) {
    console.error("L·ªói khi ƒë·ªçc n·ªôi dung file:", err);
  }
};

export const getConversations = async () => {
  const data = await readUserData();
  return data.conversations || [];
};

export const saveConversations = async (conversations) => {
  const data = await readUserData();
  const MAX_CONVERSATIONS = 100;
  data.conversations = conversations.slice(0, MAX_CONVERSATIONS);
  await writeUserData(data);
  const verify = await readUserData();
  console.log("‚úÖ ƒê√£ l∆∞u, ki·ªÉm tra l·∫°i messages:", verify.messages);

  return data.conversations;
};

export const getMessages = async (conversationId) => {
  const data = await readUserData();
  const messages = data.messages?.[conversationId] || [];
  console.log("Data t·ª´ readUserData:", data);

  // Ensure messages are returned as an array
  if (Array.isArray(messages) && messages.length > 0) {
    return messages.map((msg) => ({
      ...msg,
      replyData: msg.replyData || null, // Ensure replyData is not undefined
    }));
  }

  // Fallback to lastMessage if no messages are found
  const conversation = data.conversations?.find(
    (conv) => conv.conversationId === conversationId
  );
  if (conversation?.lastMessage) {
    return [
      {
        messageDetailId: conversation.newestMessageId,
        content: conversation.lastMessage.content,
        type: conversation.lastMessage.type,
        senderId: conversation.lastMessage.senderId,
        createdAt: conversation.lastMessage.createdAt,
      },
    ];
  }

  return [];
};

export const saveMessages = async (
  conversationId,
  newMessages,
  direction = "after"
) => {
  const data = await readUserData();
  const oldMessages = data.messages?.[conversationId] || [];

  // Lo·∫°i b·ªè tin nh·∫Øn tr√πng l·∫∑p d·ª±a tr√™n messageDetailId
  const merged =
    direction === "before"
      ? [...newMessages, ...oldMessages]
      : [...oldMessages, ...newMessages];
  const deduped = Array.from(
    new Map(
      merged
        .filter((m) => m && m.messageDetailId)
        .map((m) => [m.messageDetailId, m])
    ).values()
  );

  // Gi·ªõi h·∫°n s·ªë l∆∞·ª£ng tin nh·∫Øn
  const MAX_MESSAGES = 1000;
  const limited = deduped.slice(0, MAX_MESSAGES);

  // Kh·ªüi t·∫°o messages n·∫øu ch∆∞a t·ªìn t·∫°i
  if (!data.messages) data.messages = {};
  data.messages[conversationId] = limited;

  // C·∫≠p nh·∫≠t lastMessage trong conversation
  const latestMessage = limited.find(
    (m) => m.messageDetailId === limited[limited.length - 1]?.messageDetailId
  );
  if (latestMessage) {
    const conversation = data.conversations?.find(
      (conv) => conv.conversationId === conversationId
    );
    if (conversation) {
      conversation.lastMessage = {
        content: latestMessage.content,
        type: latestMessage.type,
        senderId: latestMessage.senderId,
        createdAt: latestMessage.createdAt,
      };
      conversation.newestMessageId = latestMessage.messageDetailId;
      conversation.lastChange = latestMessage.createdAt;
    }
  }

  await writeUserData(data);
  const verify = await readUserData();
  console.log("‚úÖ ƒê√£ l∆∞u, ki·ªÉm tra l·∫°i messages:", verify.messages);

  console.log("üíæ ƒêang l∆∞u tin nh·∫Øn cho:", conversationId);
  console.log("üî¢ S·ªë l∆∞·ª£ng m·ªõi:", newMessages.length);
  console.log("üì¶ T·ªïng sau merge:", limited.length);

  return limited;
};

export const appendMessage = async (conversationId, message) => {
  return saveMessages(conversationId, [message], "before");
};

export const getFriends = async () => {
  const data = await readUserData();
  return data.friends || [];
};

export const saveFriends = async (friends) => {
  const data = await readUserData();
  data.friends = friends;
  await writeUserData(data);
  const verify = await readUserData();
  console.log("‚úÖ ƒê√£ l∆∞u, ki·ªÉm tra l·∫°i messages:", verify.messages);
};

export const getBackground = async () => {
  const data = await readUserData();
  return data.background || null;
};

export const saveBackground = async (bg) => {
  const data = await readUserData();
  data.background = bg;
  await writeUserData(data);
  const verify = await readUserData();
  console.log("‚úÖ ƒê√£ l∆∞u, ki·ªÉm tra l·∫°i messages:", verify.messages);
};

export const saveAttachment = async (uri, fileName) => {
  console.warn(
    "Ch·ª©c nƒÉng l∆∞u file ƒë√≠nh k√®m v√†o external ch∆∞a ƒë∆∞·ª£c ho√†n thi·ªán."
  );
  return uri;
};

export const deleteAttachment = async (filePath) => {
  try {
    await FileSystem.deleteAsync(filePath, { idempotent: true });
  } catch (err) {
    console.error("L·ªói khi x√≥a ƒë√≠nh k√®m:", err);
  }
};

export const clearAllStorage = async () => {
  try {
    await AsyncStorage.removeItem(DIRECTORY_KEY);
    console.log("ƒê√£ x√≥a th√¥ng tin th∆∞ m·ª•c l∆∞u.");
  } catch (err) {
    console.error("L·ªói khi x√≥a URI l∆∞u:", err);
  }
};

export const checkStoragePaths = async () => {
  try {
    const dirUri = await getBaseDir();
    const files = await StorageAccessFramework.readDirectoryAsync(dirUri);
    console.log("üìÇ File hi·ªán c√≥:", files);
    return files;
  } catch (err) {
    console.error("L·ªói ki·ªÉm tra file:", err);
    return [];
  }
};
